package org.fencepost.bloom

import scala.collection.BitSet
import scala.math.abs
import scala.math.pow

import org.apache.commons.lang.math.RandomUtils

import com.facebook.infrastructure.utils.MurmurHash

class BloomFilter(vals:Stream[String],maskbits:Int,fncount:Int) extends StringFilter {

  private val hash = new MurmurHash()

  // maskbits determines how many bits of the internal hash result we wish to
  // keep.  MurmurHash is a 32-bit hash value so the max possible output is
  // 2^32 - 1 ~= 4.3B.  Since bit sets are sized by the largest value stored
  // this set would consume 4.3B/8 bits/byte ~= 530MB.  A value of maskbits
  // below 32 limits the size of the max possible hash function, thus making
  // it a scaling factor to enable various trade-offs between memory usage
  // and Bloom filter accuracy.  A larger maskbits value will allow for a wider
  // range of hash values (thus decreasing the chance of hash collisions) while
  // using more memory.  A smaller value brings about the opposite behaviour.

  // Build a consistent set of hash functions to apply to every input val
  val mask:Int = pow(2,maskbits).toInt - 1
  println("Mask: " + mask)
  private val fns = (1 to fncount) map { arg =>

    // Fix a random seed value before creating our closure.  If we try to
    // do this within the function itself we'll generate a new random number
    // each time we invoke the function, the result of which is that no two
    // function invocations will produce the same output unless the same random
    // value happens to be generated.
    val random = RandomUtils.nextInt()
    (subarg:String) => 
      abs(hash.hash(subarg.getBytes,subarg.getBytes.length,random)) & mask
  }

  // Evaluate our set of hash functions against the input string and return
  // a list containing the results
  private def evalAllFns(arg:String) = fns map { _ apply arg }

  // The heart of the Bloom filter; a bit set consisting of ints generated by the
  // set of functions for each input.
  private val bloom = (BitSet() /: (vals map evalAllFns))(_ ++ _)
  println("Bloom size: " + bloom.size)

  override def contains(arg:String) = {
    evalAllFns(arg) forall (bloom contains _)
  }

  override def toString = "Bloom filter: " + bloom
}
