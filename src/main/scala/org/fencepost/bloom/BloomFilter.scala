package org.fencepost.bloom

import scala.collection.mutable.BitSet
import scala.math.abs
import scala.math.pow

import org.apache.commons.lang.math.RandomUtils

import com.facebook.infrastructure.utils.MurmurHash

// Simple Bloom filter implementation.
//
// maskbits determines how many bits of the hash result we wish to keep.
// MurmurHash is a 32-bit hash value so the max possible output is
// 2^32 - 1 ~= 4.3B.  Since bit sets are sized by the largest value in the set
// this implementation would consume 4.3B/8 bits/byte ~= 530MB in the worst case.
// A value of maskbits below 32 limits the size of the max return value from the
// hash, making it a scaling factor to enable various trade-offs between memory
// usage and false positive rate.  A smaller maskbit value will increase the
// false positive rate since multiple MurmurHash outputs will now evaluate to
// the same applied bit set within our hash function.
class BloomFilter(vals:Stream[String],maskbits:Int,fncount:Int) extends Filter[String] {

  private val murmur = new MurmurHash()

  // Build a consistent set of hash functions to apply to every input val
  val mask:Int = pow(2,maskbits).toInt - 1
  private val fns = (1 to fncount) map { arg =>

    // Fix a random seed value before creating our closure.  If we try to
    // do this within the function itself we'll generate a new random number
    // each time we invoke the function, the result of which is that no two
    // function invocations will produce the same output unless the same random
    // value happens to be generated.
    val random = RandomUtils.nextInt()
    (subarg:String) =>

      // Scala's bit set implementation accepts only non-negative integers so
      // we're forced to use abs() here.  Note that this will increase the false
      // positive rate since at least two outputs from MurmurHash will produce
      // the same output from our hash function.
      abs(murmur.hash(subarg.getBytes,subarg.getBytes.length,random)) & mask
  }

  // Evaluate our set of hash functions against the input string and return
  // a list containing the results
  private def evalAllFns(arg:String):Seq[Int] = fns map { _ apply arg }

  // The heart of the Bloom filter; a bit set consisting of ints generated by the
  // set of functions for each input.
  //private val bloom = (BitSet() /: (vals flatMap evalAllFns))(_ + _)
  private val bloom = BitSet()
  for (aval <- (vals flatMap evalAllFns)) { bloom += aval }

  override def contains(arg:String):Boolean = {
    evalAllFns(arg) forall (bloom contains _)
  }

  override def toString = "Bloom filter: " + bloom
}
